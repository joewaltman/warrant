--!strict
-- AntiExploit | WARRANT: Case Closed
-- Server-side validation for combat, evidence, and progression actions

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local AntiExploit = {}

-- Rate limiting per player per action
local rateLimits: { [number]: { [string]: { count: number, resetTime: number } } } = {}

local RATE_LIMITS = {
	fireWeapon = { maxCount = 30, windowSeconds = 1 },
	discoverEvidence = { maxCount = 5, windowSeconds = 1 },
	breach = { maxCount = 1, windowSeconds = 5 },
	interact = { maxCount = 10, windowSeconds = 1 },
}

local function getPlayerLimits(userId: number): { [string]: { count: number, resetTime: number } }
	if not rateLimits[userId] then
		rateLimits[userId] = {}
	end
	return rateLimits[userId]
end

function AntiExploit.checkRateLimit(player: Player, action: string): boolean
	local config = RATE_LIMITS[action]
	if not config then
		return true
	end

	local limits = getPlayerLimits(player.UserId)
	local entry = limits[action]
	local now = tick()

	if not entry or now >= entry.resetTime then
		limits[action] = { count = 1, resetTime = now + config.windowSeconds }
		return true
	end

	entry.count += 1
	if entry.count > config.maxCount then
		warn("[AntiExploit] Rate limit exceeded:", player.Name, action, entry.count)
		return false
	end

	return true
end

-- Validate that a raycast origin is near the player's actual position
function AntiExploit.validateRayOrigin(player: Player, origin: Vector3, maxDistance: number?): boolean
	local character = player.Character
	if not character then
		return false
	end

	local rootPart = character:FindFirstChild("HumanoidRootPart") :: BasePart?
	if not rootPart then
		return false
	end

	local distance = (rootPart.Position - origin).Magnitude
	local maxDist = maxDistance or 10

	if distance > maxDist then
		warn("[AntiExploit] Ray origin too far from player:", player.Name, distance)
		return false
	end

	return true
end

-- Validate player is within interaction range of a target position
function AntiExploit.validateProximity(player: Player, targetPosition: Vector3, maxRange: number): boolean
	local character = player.Character
	if not character then
		return false
	end

	local rootPart = character:FindFirstChild("HumanoidRootPart") :: BasePart?
	if not rootPart then
		return false
	end

	local distance = (rootPart.Position - targetPosition).Magnitude
	return distance <= maxRange
end

-- Validate speed (detect teleport exploits)
local lastPositions: { [number]: { position: Vector3, time: number } } = {}
local MAX_SPEED = 100 -- studs per second (generous for normal gameplay)

function AntiExploit.validateMovement(player: Player): boolean
	local character = player.Character
	if not character then
		return true
	end

	local rootPart = character:FindFirstChild("HumanoidRootPart") :: BasePart?
	if not rootPart then
		return true
	end

	local now = tick()
	local last = lastPositions[player.UserId]

	if not last then
		lastPositions[player.UserId] = { position = rootPart.Position, time = now }
		return true
	end

	local dt = now - last.time
	if dt < 0.1 then
		return true -- too soon to check
	end

	local distance = (rootPart.Position - last.position).Magnitude
	local speed = distance / dt

	lastPositions[player.UserId] = { position = rootPart.Position, time = now }

	if speed > MAX_SPEED then
		warn("[AntiExploit] Speed violation:", player.Name, speed, "studs/s")
		return false
	end

	return true
end

function AntiExploit.cleanup(player: Player)
	rateLimits[player.UserId] = nil
	lastPositions[player.UserId] = nil
end

return AntiExploit
